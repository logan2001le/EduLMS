export interface TimeRange {
    startTime?: string;
    endTime?: string;
    startDate?: string;
    endDate?: string;
}
export declare class SchedulerMessageUtils {
    dateFormats: {
        date: string;
        time: string;
    };
    tempQuickSelectAvailablityObsj: any;
    availabilityObject: any;
    tempQuickSelectAvailablityObj: any;
    quickSelectAvailablityObj: any;
    getTimeZoneName(): string;
    getMinSlotsFromRange({ startTime, endTime, slotDuration, selectedSlots, bufferDuration, timeFormat }: {
        startTime: string;
        endTime: string;
        slotDuration?: number;
        selectedSlots?: TimeRange[];
        bufferDuration?: number;
        timeFormat?: string;
    }): any;
    getDaysInRange: ({ startDate, endDate }: {
        startDate: any;
        endDate: any;
    }) => {
        day: string;
        date: string;
    }[];
    addMinutes: (time: string, minutes: number) => string;
    convertToATimeZone: (time: number | string, timeZone: string, formats: "yyyy-MM-dd" | "HHmm" | string, usingFunc: "fromMillis" | "fromFormat", fromFormat?: string) => string;
    getDayFomDate: (date: any) => string;
    getConvertedAvailablityObjectForDate: (date: string, day: string, availabilityObj: any, newObj: any, timeZone?: string) => void;
    findLongestMeeting(meetings: TimeRange[]): TimeRange[];
    getInitialAvailableDays: ({ date, availability, timeZoneCode, blockedTime, bufferTime, duration, quickSlotDate }: {
        date: any;
        availability: any;
        timeZoneCode: any;
        blockedTime?: any;
        bufferTime?: number | undefined;
        duration?: number | undefined;
        quickSlotDate?: string | undefined;
    }) => Promise<{
        availableSlots: any;
        quickSlots: any;
    }>;
    convertToISOString(timeStr: string, dateStr: string): string;
    getCurrentDate(): string;
    formatTime(minutes: number, timeFormat: string): string;
    combineAvailability: (availability: any) => any[];
    getMeetingSlots: ({ date, availabilityObject, blockedTime, timeFormat, duration, bufferTime }: {
        date: any;
        availabilityObject: any;
        blockedTime: Record<string, TimeRange[]>;
        timeFormat?: string | undefined;
        duration: number;
        bufferTime: number;
    }) => Promise<string[]>;
    formatDate(date: Date): string;
    getFormatedDateString: ({ date, format, }: {
        date: string | Date | number;
        format: "YYYY-DD-MM" | "HHmm" | string;
    }) => string;
    convertDate: (dateStr: any) => string;
    convertToLocalTimeZone: (time: string, timeZone: string, formats: "yyyy-MM-dd" | "HHmm" | string) => string;
    getNextFormatedDate: (date: any, previous?: boolean) => string;
    toEpoch(time: string, date: string): number;
    getSlotsForADate: (blockedTime: Record<string, TimeRange[]>, date: string, bufferTime: number, duration: number, timeFormat?: string, datesAvailability?: Record<string, TimeRange[]>, timezoneCode?: string) => Promise<any>;
    getNextQuickSlots: (date: any, currentRange: any, bufferTime: number, duration: number, blockedTime: Record<string, TimeRange[]>) => Promise<any>;
    getQuickSelectSlots: (date: any, blockedTime: Record<string, TimeRange[]>, availabilityObj: any, bufferTime: number, duration: number) => Promise<any>;
}
//# sourceMappingURL=SchedulerMessageUtils.d.ts.map